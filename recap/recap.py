# ë³µì¡ë„
# ì‹œê°„ ë³µì¡ë„, ê³µê°„ ë³µì¡ë„ê°€ ìˆë‹¤. ë³µì¡ë„ì— ë”°ë¼ í’€ì´ë²•ì´ ë‹¬ë¼ì§„ë‹¤!

# ì‹œê°„ ë³µì¡ë„
# ë³´í†µ ì—°ì‚° íšŸìˆ˜: Cì–¸ì–´ ê¸°ì¤€ 1ì´ˆì— 10ì–µ(1,000,000,000)ì´í•˜
# ë³´í†µ ì—°ì‚° íšŸìˆ˜: python ê¸°ì¤€ 1ì´ˆì— 2000ë§Œ(20,000,000)
# ë³´í†µ ì—°ì‚° íšŸìˆ˜: pypy3 ê¸°ì¤€ 1ì´ˆì— 2000ë§Œ(20,000,000) ~ 1ì–µ(100,000,000)ì´í•˜
# 1ì´ˆì¼ ê²½ìš°
# Nì´ 500 ì¸ ê²½ìš°: O(N**3)
# Nì´ 2000 ì¸ ê²½ìš°: O(N**)
# Nì´ 100,000 ì¸ ê²½ìš°: O(NlogN)
# Nì´ 10,000,000 ì¸ ê²½ìš°: O(N)

# ê³µê°„ ë³µì¡ë„
# ë³´í†µ 128MB - 512MBë¡œ ì œí•œí•œë‹¤.
# a[1000]: 4KB
# a[1000000]: 4MB
# a[2000][2000]: 16MB
# a[100000000]: 400MB



# -------------------------------------------------------------------------- 3ê°€ì§€ ìë£Œêµ¬ì¡°
#--------------------------------------- ìŠ¤íƒ (ê¸°ë³¸ ë¦¬ìŠ¤íŠ¸)
# ì‚½ì…  O(1)
# ì‚­ì œ  O(N)
# First In Last Out -ì„ ì…í›„ì¶œ

# array = [1,2,3,4,5]
# array.append(2)
# array.pop()

# print(array)
# print(array[::-1]) //ìµœìƒë‹¨ ì›ì†Œë¶€í„° ì¶œë ¥


#--------------------------------------- í (deque)
# First In First Out -ì„ ì…ì„ ì¶œ

# from collections import deque
# q = deque()
# q.append(1)
# q.popleft()


#--------------------------------------- ìš°ì„ ìˆœìœ„ í(ìµœì†Œ í™)
# ì‚½ì…,ì‚­ì œ ì „ë¶€ O(logN)
# ì²«ë²ˆì§¸ ì›ì†Œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ë¥¼ ì„¤ì •í•œë‹¤.
# (ê°€ì¹˜, ë¬¼ê±´ë²ˆí˜¸)ë¡œ ì„¤ì •í•˜ë©´ ê°€ì¹˜ ìˆœì„œëŒ€ë¡œ ì •ë ¬ ë¨
# ê¸°ë³¸ì´ ìµœì†Œ í™
# ìµœëŒ€ í™ìœ¼ë¡œ ì‚¬ìš©í•˜ë ¤ë©´
# í™ì— ë„£ê¸° ì „ì— ìŒìˆ˜ë¡œ ë°”ê¾¼ í›„ ë„£ê³ 
# ëº€ ë‹¤ìŒì— ë‹¤ì‹œ ì •ìˆ˜ë¡œ ë°”ê¾¼ë‹¤.

# import heapq
# heapq.heappush(q,(0,start))
# heapq.heappop(q)

# -------------------------------------------------------------------------- ê·¸ë¦¬ë””
# í˜„ì¬ ê°€ì¥ ì¢‹ì€ ê²ƒë§Œì„ ì„ íƒí–ˆì„ ë•Œ,
# ì •í™•í•œ ë‹µì„ ì°¾ì„ ìˆ˜ ìˆë‹¤ëŠ” ë³´ì¥ì´ ìˆì„ ë•Œ ì‚¬ìš©.
# ë¬¸ì œ ìœ í˜•ì„ íŒŒì•…í•˜ê¸° ì–´ë µë‹¤ë©´,
# ê·¸ë¦¬ë”” ì˜ì‹¬!
# í˜„ì¬ì˜ ì„ íƒì´ ë‚˜ì¤‘ì— ë¯¸ì¹  ì˜í–¥ì— ëŒ€í•´ ê³ ë ¤í•˜ì§€ ì•ŠëŠ”ë‹¤.
# í”Œë¡œì´ë“œ ì›Œì…œ
# ë‹¤ìµìŠ¤íŠ¸ë¼
# íŠ¹íˆ ê·¸ë¦¬ë””ëŠ” ë§ì€ ìœ í˜• ì ‘í•˜ê³  í’€ì–´ë³´ëŠ” ìˆ˜ ë°–ì— ì—†ë‹¤.


# -------------------------------------------------------------------------- êµ¬í˜„
# ì™„ì „íƒìƒ‰, ì‹œë®¬ë ˆì´ì…˜
# ë°ì´í„° ì²˜ë¦¬ëŸ‰ì´ ë§ì„ ë•ŒëŠ” ë©”ëª¨ë¦¬ ì œí•œì„ ê³ ë ¤í•˜ì
# í’€ì´ë¥¼ ë– ì˜¬ë¦¬ê¸°ëŠ” ì‰½ì§€ë§Œ ì½”ë“œë¡œ ì˜®ê¸°ê¸° ì–´ë ¤ìš´ ë¬¸ì œ
# ì•Œê³ ë¦¬ì¦˜ì€ ê°„ë‹¨í•œë° ì½”ë“œê°€ ë§¤ìš° ê¸¸ì–´ì§€ëŠ” ë¬¸ì œ
# íŠ¹ì • ì†Œìˆ˜ì ìë¦¬ê¹Œì§€ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ
# ë¬¸ìì—´ì„ í•œ ë¬¸ì ë‹¨ìœ„ë¡œ ëŠì–´ì„œ ë¦¬ìŠ¤íŠ¸ì— ë„£ì–´ì•¼í•˜ëŠ” ë¬¸ì œ
# ëŒ€ì²´ë¡œ ê¹Œë‹¤ë¡œìš´ ì¡°ê±´ë“¤ì´ ë§ë‹¤.
# ê°ì€ ì¡íˆëŠ”ë° ë§‰ìƒ ì½”ë“œë¡œ ì˜®ê¸°ìë‹ˆ ë§‰ë§‰ => ê° ë‹¨ê³„ë§ˆë‹¤ í•¨ìˆ˜í™”ë¥¼ ì‹œì¼œì„œ ë‚˜ëˆ ì„œ ìƒê°í•˜ì.


#-------------------------------------------------------------------------- DFS ì™€ BFS
# 2ì°¨ì› ë°°ì—´ì—ì„œ íƒìƒ‰ ë¬¸ì œë¥¼ ë§Œë‚˜ë©´, ê·¸ë˜í”„ í˜•íƒœë¡œ í‘œí˜„í•œ ë‹¤ìŒ í’€ì´ë²• ê³ ë¯¼!
# ë‚˜ì˜ ê²½í—˜ìœ¼ë¡œ ì¼ë‹¨ ë§ëŠ” ê²ƒ ê°™ì€ ì•Œê³ ë¦¬ì¦˜ ì¨ë†“ê³  ê·¸ê³³ì—ë‹¤ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ë” íš¨ìœ¨ì ì´ë‹¤.
# ì•„ë¬´ê²ƒë„ ì•ˆ ì“°ë©´ ì•„ë¬´ê²ƒë„ ìƒê° ì•ˆë‚¨.

#--------------------------------------- DFS
# ì¸ì ‘ ë¦¬ìŠ¤íŠ¸: ê³µê°„ë³µì¡ë„ O(E) EëŠ” ê°„ì„ ì˜ ê°¯ìˆ˜
# ê°„ì„ ì˜ ë¹„ìš©ì„ O(V)ì‹œê°„ë§Œì— ì•Œ ìˆ˜ ìˆë‹¤.
# ìŠ¤íƒ ìë£Œêµ¬ì¡° ì´ìš©
# ì¬ê·€í•¨ìˆ˜
# O(N)

# def dfs(graph,start,visited):
#   visited[start] = True
#   print(start, end=' ')
#   for i in graph[start]:
#     if visited[start] == False:
#       dfs(graph,i,visited)

#--------------------------------------- BFS
# ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ : ê³µê°„ë³µì¡ë„ O(E) EëŠ” ê°„ì„ ì˜ ê°¯ìˆ˜
# ê°„ì„ ì˜ ë¹„ìš©ì„ O(V)ì‹œê°„ë§Œì— ì•Œ ìˆ˜ ìˆë‹¤.
# í ìë£Œêµ¬ì¡° ì´ìš© deque
# ì¼ë°˜ì ìœ¼ë¡œ dfsë³´ë‹¤ ì‚´ì§ ë” ë¹ ë¥´ë‹¤.
# O(N)

# from collections import deque

# def bfs(graph,start,visited):
#   q = deque([start])
#   visited[start] = True
#   while q:
#     now = q.popleft()
#     print(now, end=' ')
#     for i in graph[now]:
#       if visited[i] == False:
#         visited[i] = True
#         q.append(i)


#-------------------------------------------------------------------------- ì •ë ¬
# array = [6,4,5,9,1,8,2,3,7]
# n = len(array)
# ì‹¤ì œë¡œëŠ” sort()ë‚˜ sorted ì‚¬ìš©
# ìµœì•…ì˜ ê²½ìš°ì—ë„ O(NlogN)
# ë³‘í•©ì •ë ¬, í•˜ì´ë¸Œë¦¬ë“œ ì •ë ¬
# (ì†ë„ê°€ ë¹„êµê°€ ì•ˆë  ì •ë„ë¡œ ë¹ ë¥´ë‹¤)
# sorted()ëŠ” ê¸°ì¡´ ê°’ ë³€ê²½ ì•ˆí•¨,  return ê°’ì´ ìˆë‹¤.
# sort()ëŠ” ê¸°ì¡´ ê°’ ë³€ê²½, return ê°’ ì—†ë‹¤.
# array.reverse()
# array.sort(reverse=True)
# array.sort(key = lambda x: (-float(x[0]), int(x[1])))
# array.sort(key = lambda x: (-x[1], x[2], -x[3], x[0]))

#--------------------------------------- ì„ íƒì •ë ¬
# O(N2) - ì´ì¤‘ ë°˜ë³µë¬¸
# for i in range(n):
#   min_value = i
#   for j in range(i+1, n):
#     if array[min_value] > array[j]:
#       min_value = j
#   array[min_value],array[i] = array[i], array[min_value]


#--------------------------------------- ì‚½ì…ì •ë ¬
# O(N2) - ì´ì¤‘ ë°˜ë³µë¬¸ 
# ë°ì´í„°ê°€ ê±°ì˜ ì •ë ¬ë˜ì–´ ìˆì„ ë•ŒëŠ” ê°€ì¥ ë¹ ë¥´ë‹¤!!
# ìµœì„ ì˜ ê²½ìš° O(N)
# for i in range(1,n):
#   for j in range(i,0,-1):
#     if array[j] < array[j-1]:
#       array[j],array[j-1] = array[j-1],array[j]
#     else:
#       break


#--------------------------------------- í€µì •ë ¬
# í‰ê·  O(NlogN) ì—°ì‚°ë§ˆë‹¤ ë°˜í‰ë‚˜ëŠ” ê²ƒì´ 2ê°œì”©
# def quick_sort(array):
#   if len(array) <= 1:
#     return array

#   pivot = array[0]
#   tail = array[1:]
#   left_side = [x for x in tail if x <= pivot]
#   right_side = [x for x in tail if x > pivot]

#   return quick_sort(left_side) + [pivot] + quick_sort(right_side)


#--------------------------------------- ê³„ìˆ˜ì •ë ¬
# O(N+K)
# ë°ì´í„° í¬ê¸°ê°€ í•œì •, ì¤‘ë³µì´ ìˆì„ ìˆ˜ë¡ ìœ ë¦¬í•¨
# ê°€ì¥ í° ë°ì´í„°ì™€ ì‘ì€ ë°ì´í„°ì˜ ì°¨ì´ê°€ 1,000,000 ì„ ë„˜ì§€ ì•Šì„ ë•Œ íš¨ê³¼ì 
# ê¸°ìˆ˜ ì •ë ¬ê³¼ ë”ë¶ˆì–´ ê°€ì¥ ë¹ ë¥´ë‹¤.
# ë¹„êµê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜ì´ ì•„ë‹ˆë‹¤.
# ìê¾¸ í—·ê°ˆë¦¬ëŠ”ë°, ì¸ë±ìŠ¤ ê°’ì´ ì•„ë‹Œ ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ê°€ì¥ í° ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ë§Œë“¤ì–´ì•¼ í•œë‹¤.
# dp = [0] * (max(array)+1)

# for i in range(n):
#   dp[array[i]] += 1

# for i in range(n):
#   for _ in range(dp[i]):
#     print(i, end=' ')

# ê¸°ìˆ˜ì •ë ¬ì´ë€?

#--------------------------------------------------------------------------ì´ì§„íƒìƒ‰
# ì •ë ¬ë˜ì§€ ì•Šì€ ë¦¬ìŠ¤íŠ¸ì—ì„œ ë°ì´í„°ë¥¼ ì°¾ì„ ë•Œ, ìˆœì°¨ íƒìƒ‰ì„ ì‚¬ìš©í•œë‹¤.
# ìˆœì°¨íƒìƒ‰ ì‹œê°„ë³µì¡ë„: O(N)
# ë°ì´í„°ê°€ ì •ë ¬ë˜ì–´ìˆë‹¤ë©´ ì´ì§„íƒìƒ‰ ê°€ëŠ¥!!
# ì´ì§„íƒìƒ‰ ì‹œê°„ë³µì¡ë„: O(logN)
# ë°˜í‰í•œë‹¤ëŠ” ì ì—ì„œ í€µ ì •ë ¬ê³¼ ë¹„ìŠ·
# ê·¸ë¦¬ë””ì™€ ì´ì§„íƒìƒ‰ì´ í•¨ê»˜ ë‚˜ì˜¤ëŠ” ê³ ë‚œì´ë„ ë¬¸ì œê°€ ë‚˜ì˜¨ë‹¤!!
# ì´ì§„íƒìƒ‰ êµ¬í˜„ì€ ê»Œìœ¼ë¡œ í•´ì•¼ í•´!!

# ì´ì§„íƒìƒ‰ì€ íš¨ìœ¨ì ì´ê¸°ì—
# ì…ë ¥ ë°ì´í„°ê°€ ë§ê±°ë‚˜ íƒìƒ‰ ë²”ìœ„ê°€ ë§¤ìš° ë„“ë‹¤.
# ë”°ë¼ì„œ input()ì„ ë” ë¹ ë¥¸ ê²ƒìœ¼ë¡œ ë°”ê¿”ë³´ì
# readline()ì´í›„ ì—”í„°ê°€ ì¤„ ë°”ê¿ˆ ê¸°í˜¸ë¡œ ì…ë ¥ë˜ëŠ”ë°,
# ì´ ê³µë°± ë¬¸ìë¥¼ ì œê±°í•˜ê¸° ìœ„í•´ rstrip()í•¨ìˆ˜ ì‚¬ìš©
# import sys
# sys.stdin.readline().rstrip()

# --------------------------------------- ì¬ê·€í•¨ìˆ˜
# def binary_re(array, target, start, end):
#   if start>end:
#     return None
#   mid = (start + end) //2
#   if array[mid] == target:
#     return mid
#   elif array[mid] > target:
#     return binary_re(array,target,start,mid-1)
#   else:
#     return binary_re(array,target,mid+1, end)

# --------------------------------------- ë°˜ë³µë¬¸
# def binary(array, target, start, end):
#   while start <= end:
#     mid = (start + end)//2
#     if array[mid] == target:
#       return mid
#     elif array[mid] < target:
#       start = mid+1
#     else:
#       end = mid-1
#   return None

# --------------------------------------- bisect ë¼ì´ë¸ŒëŸ¬ë¦¬
# ì´ì§„íƒìƒ‰ ì‹œê°„ë³µì¡ë„: O(logN)
# ê°ê° ë¦¬ìŠ¤íŠ¸ aì— ë°ì´í„° xë¥¼ ì‚½ì…í•  ê°€ì¥ ì™¼ìª½ ì¸ë±ìŠ¤, ì˜¤ë¥¸ìª½ ì¸ë±ìŠ¤ë¥¼ ì°¾ëŠ”ë‹¤.
# íŠ¹ì • ë²”ìœ„ì— ì†í•˜ëŠ” ì›ì†Œì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ê³ ì í•  ë•Œ íš¨ê³¼ì 
# from bisect import bisect_left, bisect_right
# a = [1,2,3,3,3,3,4,4,8,9]

# def count_by_range(a,left_value, right_value):
#   left_index = bisect_left(a,left_value)
#   right_index = bisect_right(a,right_value)

#   return right_index - left_index


# íŠ¸ë¦¬ ìë£Œêµ¬ì¡°
# ë¶€ëª¨ì™€ ìì‹ ê´€ê³„
# ìµœìƒë‹¨ ë…¸ë“œë¥¼ ë£¨íŠ¸ë…¸ë“œ
# ìµœí•˜ë‹¨ ë…¸ë“œë¥¼ ë‹¨ë§ë…¸ë“œ
# ì¼ë¶€ë¥¼ ë–¼ì–´ë‚´ë„ íŠ¸ë¦¬êµ¬ì¡° ìœ ì§€
# íŒŒì¼ ì‹œìŠ¤í…œì²˜ëŸ¼ ê³„ì¸µì ì´ê³  ì •ë ¬ëœ ë°ì´í„°ë¥¼ ë‹¤ë£¨ê¸°ì— ì í•©
# ì™¼ìª½ ìì‹ < ë¶€ëª¨ < ì˜¤ë¥¸ìª½ ìì‹



#-------------------------------------------------------------------------- ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°
# ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜
# ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜
# ë©”ëª¨ì´ì œì´ì…˜: ë•Œì— ë”°ë¼ ì‚¬ì „ ìë£Œí˜•ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆë°!
# ì í™”ì‹!!!
# ë‘ ê°€ì§€ ì¡°ê±´
# í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤.
# ì‘ì€ ë¬¸ì œì—ì„œ êµ¬í•œ ì •ë‹µì€ ê·¸ê²ƒì„ í¬í•¨í•˜ëŠ” í° ë¬¸ì œì—ì„œë„ ë™ì¼í•˜ë‹¤.
# ì™„ì „íƒìƒ‰ì´ ë„ˆë¬´ ì˜¤ë˜ ê±¸ë¦¬ë©´ ë‹¤ì´ë‚˜ë¯¹ì„ ì˜ì‹¬í•´ë³´ì!
# ë¹„íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•œ í›„ ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ì½”ë“œ ê°œì„ í•˜ëŠ” ê²ƒë„ ì¢‹ì€ ë°©ë²•!!
# ì‹œê°„ë³µì¡ë„: O(N)
# ---------------------------------------ì¬ê·€í•¨ìˆ˜ ë²„ì „
# íƒ‘ë‹¤ìš´ ë°©ì‹: ì˜¤ë²„í—¤ë“œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
# ì˜¤ì²œë²ˆì§¸ ì´ìƒ recursive ë˜ë©´ recursive depth ê´€ë ¨ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
# setrecursionlimit()ì„ ì´ìš©í•´ì„œ ì™„í™”í•  ìˆ˜ëŠ” ìˆë‹¤.
# dp = [0]*(x+1)

# def fibo_re(x):
#   if x == 1 or x == 2:
#     return 1
#   if dp[x] != 0:
#     return dp[x]
#   dp[x] = fibo_re(x-1) + fibo_re(x-2)
#   return dp[x]

#--------------------------------------- ë°˜ë³µë¬¸ ë²„ì „ ì¶”ì²œ!
# ë³´í…€ì—… ë°©ì‹
# d = [0] * (n+1)

# d[1] = 1
# d[2] = 1
# n = 99

# for i in range(3,n+1):
#   d[i] = d[i-1] + d[i-2]


#-------------------------------------------------------------------------- ìµœë‹¨ ê²½ë¡œ
# ê°„ì„ ì˜ ê°¯ìˆ˜ê°€ ë§ìœ¼ë©´ ë‹¤ìµìŠ¤íŠ¸ë¼,
# ì ìœ¼ë©´ í”Œë¡œì´ë“œ ì›Œì…œ ğŸ˜‚
# --------------------------------------- ë‹¤ìµìŠ¤íŠ¸ë¼
# ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜
# ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°ì´ê¸°ë„ í•¨! - ë©”ëª¨ì´ì œì´ì…˜ ë¹„ìŠ¤ë¬´ë¦¬
# ì¸ì ‘ ë¦¬ìŠ¤íŠ¸: ê³µê°„ë³µì¡ë„ O(E) EëŠ” ê°„ì„ ì˜ ê°¯ìˆ˜
# ê°„ì„ ì˜ ë¹„ìš©ì„ O(V)ì‹œê°„ë§Œì— ì•Œ ìˆ˜ ìˆë‹¤.
# ì‹œê°„ë³µì¡ë„: O(ElogV)
# ì—¬ê¸°ì„œ EëŠ” ìµœëŒ€ ê°„ì„  ê°¯ìˆ˜
# EëŠ” í•­ìƒ Vì œê³±ë³´ë‹¤ ì‘ë‹¤. ëª¨ë“  ë…¸ë“œë¼ë¦¬ ì—°ê²°ë˜ì–´ìˆì„ ê²½ìš° Vì œê³±ì´ê¸° ë•Œë¬¸.
# ì‘ì€ ê°’ì´ í•­ìƒ ê°€ì¥ ë¨¼ì € ë‚˜ì˜¤ëŠ” ìš°ì„ ìˆœìœ„ í(heapq) ìë£Œêµ¬ì¡° ì‚¬ìš©
# í™ì„ ì‚¬ìš©í•˜ëŠ” ìµœì†Œ ì‹ ì¥íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ê³¼ë„ ë¹„ìŠ·í•œ ëŠë‚Œ
# import heapq

# INF = int(1e9)
# n,m = map(int,input().split())
# graph = [[] for _ in range(n+1)]
# distance = [INF]*(n+1)

# for _ in range(m):
#   a,b,c = map(int,input().split())
#   graph[a].append((b,c))

# def dijkstra(start):
#   q = []
#   heapq.heappush(q,(0,start))
#   distance[start] = 0
#   while q:
#     dist,now = heapq.heappop(q)
#     if distance[now] < dist:
#       continue
#     for i in graph[now]:
#       cost = dist + i[1]
#       if cost < distance[i[0]]:
#         distance[i[0]] = cost
#         heapq.heappush(q,(cost,i[0]))


# --------------------------------------- í”Œë¡œì´ë“œ ì›Œì…œ
# ì¸ì ‘ í–‰ë ¬ ê·¸ë˜í”„: ê³µê°„ë³µì¡ë„ O(V2)
# ê°„ì„ ì˜ ë¹„ìš©ì„ O(1)ì‹œê°„ë§Œì— ì•Œ ìˆ˜ ìˆë‹¤.
# ëª¨ë“  ì§€ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì§€ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œ
# ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë° - ì í™”ì‹ ì‚¬ìš©
# ì‹œê°„ë³µì¡ë„: O(N3)
# INF = int(1e9)
# n,m = map(int,input().split())
# graph = [[INF] * (n+1) for _ in range(n+1)]

# for i in range(1,n+1):
#   for j in range(1,n+1):
#     if i == j:
#       graph[i][j] = 0

# for _ in range(m):
#   a,b,c = map(int,input().split())
#   graph[a][b] = c

# for k in range(1,n+1):
#   for i in range(1,n+1):
#     for j in range(1,n+1):
#       graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

# for i in range(1,n+1):
#   for j in range(1,n+1):
#     if graph[i][j] == INF:
#       print('INF', end=' ')
#     else:
#       print(graph[i][j], end=' ')
#   print()


#-------------------------------------------------------------------------- ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜
# ì‹ ì¥ íŠ¸ë¦¬ë€(Spanning Tree)
# ëª¨ë“  ë…¸ë“œê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ì„œ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë¬´ë°©í–¥ ê·¸ë˜í”„
# --------------------------------------- í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜)
# ìµœì†Œí•œì˜ ë¹„ìš©ìœ¼ë¡œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ì°¾ì„ ë•Œ
# ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜
# ì •ë ¬ì´ í•„ìš”í•¨
# ì‹œê°„ ë³µì¡ë„: O(ElogE)
# n,m = map(int,input().split())
# parent = [0] * (n+1)

# for i in range(1,n+1):
#   parent[i] = i

# def find_root(parent, x):
#   if parent[x] != x:
#     parent[x] = find_root(parent,parent[x])
#   return parent[x]

# def union(parent, x,y):
#   x = find_root(parent,x)
#   y = find_root(parent,y)
#   if x < y:
#     parent[y] = x
#   else:
#     parent[x] = y

# edges = []
# for _ in range(m):
#   a,b,c = map(int,input().split())
#   edges.append((c,a,b))
# edges.sort()

# result = 0
# for edge in edges:
#   cost,a,b = edge
#   if find_root(parent,a) != find_root(parent,b):
#     union(parent,a,b)
#     result += cost

# print(result)
  

# --------------------------------------- ìœ„ìƒì •ë ¬ ì•Œê³ ë¦¬ì¦˜ topology sort
# ë°©í–¥ ê·¸ë˜í”„ì˜ ëª¨ë“  ë…¸ë“œë“¤ì„ ë°©í–¥ì„±ì— ê±°ìŠ¤ë¥´ì§€ ì•Šë„ë¡ ìˆœì„œëŒ€ë¡œ ì •ë ¬
# ì§„ì…ì°¨ìˆ˜ ê°œë…: ì„ ìˆ˜ê³¼ëª©
# í ìë£Œêµ¬ì¡° or ìŠ¤íƒ ìë£Œêµ¬ì¡°
# ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•ŠëŠ” instanceê°€ ì£¼ì–´ì§„ë‹¤.
# ì‹œê°„ ë³µì¡ë„: O(V+E)

# from collections import deque

# n,m = map(int,input().split())
# graph = [[] for _ in range(n+1)]
# indegree = [0] * (n+1)

# for _ in range(m):
#   a,b = map(int,input().split())
#   graph[a].append(b)
#   indegree[b] += 1

# def topology():
#   result = []
#   q = deque()
#   for i in range(1,n+1):
#     if indegree[i] == 0:
#       q.append(i)
#   while q:
#     now = q.popleft()
#     result.append(now)
#     for i in graph[now]:
#       indegree[i] -= 1
#       if indegree[i] == 0:
#         q.append(i)
#   for i in result:
#     print(i, end=' ')

# topology()



#-------------------------------------------------------------------------- ì†Œìˆ˜ íŒë³„, ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´
# --------------------------------------- ì†Œìˆ˜ íŒë³„
# ê·¸ëƒ¥ êµ¬í˜„í•œë‹¤ë©´ O(X)ì´ì§€ë§Œ
# í•´ë‹¹ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ë©´
# O(X1/2) Xì˜ ì œê³±ê·¼
# ì•½ìˆ˜ì˜ ëŒ€ì¹­ì„±ì„ ì´ìš©í•œ ì œê³±ê·¼ ì‚¬ìš©
# import math

# def prime_number(x):
#   for i in range(2,int(math.sqrt(x)) + 1):
#     if x%i == 0:
#       return False
#   return True

#--------------------------------------- ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´
# O(NloglogN)
# ì„ í˜•ì‹œê°„ì— ê°€ê¹ê²Œ ë¹ ë¥´ë‹¤.
# ê·¸ëŸ¬ë‚˜
# ë©”ëª¨ë¦¬ê°€ ë§ì´ í•„ìš”í•˜ë‹¤.
# data = [True for _ in range(n+1)]

# for i in range(2, int(math.sqrt(x))+1):
#   if array[i] == True:
#     j = 2
#     while i*j <=n:
#       array[i*j] = False
#       j += 1

#-------------------------------------------------------------------------- íˆ¬ í¬ì¸í„°, í•©ì§‘í•©, êµ¬ê°„ í•©
#--------------------------------------- íˆ¬ í¬ì¸í„°
# ìŒìˆ˜ ë°ì´í„° ìˆì„ ê²½ìš° í•´ê²° ë¶ˆê°€

# n = 5
# m = 7
# array = [1,2,3,2,5]

# count = 0
# end = 0
# inter_sum = 0

# for start in range(n):
#   while inter_sum < m and end<n:
#     inter_sum += array[end]
#     end += 1
#   if inter_sum == m:
#     count += 1
#   inter_sum -= array[start]
  
#--------------------------------------- í•©ì§‘í•©
# a = [1,4,5,8]
# b = [2,3,6,7,9]
# d = [0] * (len(a) + len(b))

# i = 0
# j = 0
# k = 0

# while i < len(a) or j < len(b):
#   if j >= len(b) or (i < len(a) and a[i] <= b[j] ):
#     d[k] = a[i]
#     i += 1
#   else:
#     d[k]= b[i]
#     j+=1
#   k += 1

#--------------------------------------- êµ¬ê°„ í•©
# n = 5
# data = [10,20,30,40,50]

# right = 4
# left = 2

# prefix_sum = [0]
# inter_sum = 0

# for i in data :
#   inter_sum += i
#   prefix_sum.append(inter_sum)

# print(prefix_sum[right] - prefix_sum[left-1])



#-------------------------------------------------------------------------- ìˆœì—´ê³¼ ì¡°í•©
# ì „ë¶€ í´ë˜ìŠ¤ ê°œì²´ì„ìœ¼ë¡œ ë¦¬ìŠ¤íŠ¸ ìë£Œí˜•ìœ¼ë¡œ ë³€í™˜í•´ì•¼ í•œë‹¤.
# a = [1,2,3,4,5,6,7]

#-------------------------------------------- permutations
# # ìš”ì†Œ ê°„ ìˆœì„œê°€ ë‹¤ë¥´ë©´ ë‹¤ë¥´ë‹¤ê³  ì¸ì‹í•˜ëŠ”ê°€? o
# # ì¸ìŠ¤í„´ìŠ¤ ë‚´ì—ì„œ ë°˜ë³µì„ í—ˆìš©í•˜ëŠ” ê°€? x
# # len(a) * (len(a)-1) *  (len(a)-2)

# from itertools import permutations
# candi_permu = list(permutations(a,3))
# print(len(candi_permu))
# print(candi_permu)


#-------------------------------------------- combinations
# # ìš”ì†Œ ê°„ ìˆœì„œê°€ ë‹¤ë¥´ë©´ ë‹¤ë¥´ë‹¤ê³  ì¸ì‹í•˜ëŠ”ê°€? x
# # ì¸ìŠ¤í„´ìŠ¤ ë‚´ì—ì„œ ë°˜ë³µì„ í—ˆìš©í•˜ëŠ” ê°€? x
# ì¸ìˆ˜ê°€ 3ê°œ ë¼ë©´ 1
# ì¸ìˆ˜ê°€ 4ê°œ ë¼ë©´ +3 (1+2)
# ì¸ìˆ˜ê°€ 5ê°œ ë¼ë©´ +6 (1+2+3)
# ì¸ìˆ˜ê°€ 6ê°œ ë¼ë©´ +10 (1+2+3+4)
# ì¸ìˆ˜ê°€ 7ê°œ ë¼ë©´ +15 (1+2+3+4+5)

# from itertools import combinations
# candi_combi = list(combinations(a,3))
# print(len(candi_combi))
# print(candi_combi)


#-------------------------------------------- combinations_with_replacement
# # ìš”ì†Œ ê°„ ìˆœì„œê°€ ë‹¤ë¥´ë©´ ë‹¤ë¥´ë‹¤ê³  ì¸ì‹í•˜ëŠ”ê°€? x
# # ì¸ìŠ¤í„´ìŠ¤ ë‚´ì—ì„œ ë°˜ë³µì„ í—ˆìš©í•˜ëŠ” ê°€? o

# from itertools import combinations_with_replacement
# candi_combi_repl = list(combinations_with_replacement(a,3))
# print(len(candi_combi_repl))
# print(candi_combi_repl)


#-------------------------------------------- product
# # ìš”ì†Œ ê°„ ìˆœì„œê°€ ë‹¤ë¥´ë©´ ë‹¤ë¥´ë‹¤ê³  ì¸ì‹í•˜ëŠ”ê°€? o
# # ì¸ìŠ¤í„´ìŠ¤ ë‚´ì—ì„œ ë°˜ë³µì„ í—ˆìš©í•˜ëŠ” ê°€? o

# from itertools import product
# candi_product = list(product(a,repeat=3))
# print(len(candi_product))
# # len(a) ** 3



#-------------------------------------------------------------------------- 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ 90ë„ íšŒì „
# a = [[1,2,3], [4,5,6], [7,8,9]]

# def rotate_right(a):
#   row = len(a)
#   column = len(a[0])

#   res = [[0] * row for _ in range(column)]
#   for i in range(row):
#     for j in range(column):
#       res[j][row-1-i] = a[i][j]
#   return res

# def rotate_left(a):
#   row = len(a)
#   column = len(a[0])

#   res = [[0] * row for _ in range(column)]
#   for i in range(row):
#     for j in range(column):
#       res[column-1-j][i] = a[i][j]
#   return res

#-------------------------------------------------------------------------- íŒŒì´ì¬ì˜ í° ìˆ˜ì— ëŒ€í•´ 
# https://ahracho.github.io/posts/python/2017-05-09-python-integer-overflow/
# ë‹¤ë¥¸ ì–¸ì–´ëŠ” ë„ˆë¬´ í°ìˆ˜ëŠ” ë©”ëª¨ë¦¬ì˜ í•œê³„ ë•Œë¬¸ì— ì—ëŸ¬ê°€ ë‚œë‹¤.
# íŒŒì´ì¬ì€ ì—ëŸ¬ê°€ ë‚˜ì§€ ì•ŠëŠ”ë‹¤.
# íŒŒì´ì¬ì—ëŠ” ì˜¤ë²„í”Œë¡œìš°ê°€ ì—†ë‹¤
# íŒŒì´ì¬ 2ì—ì„œëŠ” ì •ìˆ˜í˜• ë°ì´í„° íƒ€ì…ì´ intì™€ long ë‘ ê°€ì§€ê°€ ìˆì—ˆëŠ”ë°, intëŠ” Cì—ì„œì˜ ê·¸ê²ƒê³¼ ê°™ì€ 4ë°”ì´íŠ¸ ë°ì´í„°í˜•ì´ê³ , 
# longì€ arbitrary precisionì„ ë”°ë¥´ëŠ” ë°ì´í„°í˜•ì´ë‹¤.
# ê·¸ë˜ì„œ int íƒ€ì… ë³€ìˆ˜ì˜ ê°’ì´ í‘œí˜„ ë²”ìœ„ë¥¼ ë„˜ì–´ì„œê²Œ ë˜ë©´ ìë™ìœ¼ë¡œ longìœ¼ë¡œ íƒ€ì… ë³€ê²½ì´ ë˜ëŠ” í˜•ì‹ì´ì—ˆë‹¤.

# íŒŒì´ì¬ 3ì—ì„œëŠ” long íƒ€ì…ì´ ì—†ì–´ì§€ê³  int íƒ€ì…ë§Œ ë‚¨ì•˜ëŠ”ë°,
# ì´ intê°€ arbitrary precisionì„ ì§€ì›í•˜ì—¬ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•˜ì§€ ì•Šê²Œ ë˜ì—ˆë‹¤.

# arbitrary precisionë€?
# ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë©”ëª¨ë¦¬ì–‘ì´ ì •í•´ì ¸ ìˆëŠ” ê¸°ì¡´ì˜ fixed-precisionê³¼ ë‹¬ë¦¬,
# ë‚¨ì•„ìˆëŠ” ë§Œí¼ì˜ ê°€ìš© ë©”ëª¨ë¦¬ë¥¼ ëª¨ë‘ ìˆ˜ í‘œí˜„ì— ëŒì–´ë‹¤ ì“¸ ìˆ˜ ìˆëŠ” í˜•íƒœ

# ê¸°ë³¸ 28ë°”ì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ë‹¤ ì´ë¥¼ ë„˜ì–´ê°€ë©´ 4ë°”ì´íŠ¸ì”© ì¦ê°€í•˜ë©´ì„œ ìˆ˜ í‘œí˜„ì— ì‚¬ìš©í•˜ëŠ” ë°”ì´íŠ¸ ìˆ˜ê°€ íƒ„ë ¥ì ìœ¼ë¡œ ëŠ˜ì–´ë‚œë‹¤.