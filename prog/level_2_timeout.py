# -------------------------------------------------------------------------------- 4. 땅따먹기 - 복습!!!!
# 같은 열을 연속해서 밟을 수 없는 특수 규칙
# 다이나믹
# 개미 곶간 터는 문제랑 비슷해
# 지금 이걸 밟는 것이 다음꺼와 함께 생각했을 때 이득인가?
# 의 반복
# ------------------------------------------- 커뮤
# def solution(land):

#   for i in range(1,len(land)):
#     for j in range(len(land[0])):
#       print(land[i-1][:j])
#       print(land[i-1][j+1:])
#       land[i][j] += max(land[i-1][:j] + land[i-1][j+1:])
#   return max(land[len(land)-1])


# print(solution([[1,2,3,5],[5,6,7,8],[4,3,2,1]]))
# print(solution([[1,2,3,5],[5,6,7,8],[1,3,10,2],[]]))


# -------------------------------------------------------------------------------- 6. 게임 맵 최단거리
# ------------------------------------------- 내꺼 시간초과 32분 컷!
# from collections import deque

# def bfs(maps,x,y):
#   dx = [0,1,0,-1]
#   dy = [1,0,-1,0]

#   q = deque([(x,y)])
#   maps[x][y] = 2
#   while q:
#     now_x, now_y =  q.popleft()
#     for i in range(4):
#       nx = now_x + dx[i]
#       ny = now_y + dy[i]
#       if 0 <= nx < len(maps) and 0 <= ny < len(maps[0]):
#         if maps[nx][ny] == 1:
#           maps[nx][ny] = maps[now_x][now_y]+1
#           q.append((nx,ny))

# def solution(maps):
#   n = len(maps)
#   m = len(maps[0])
#   bfs(maps, 0,0)
#   if maps[n-1][m-1] == 1:
#     return -1
#   else:
#     return maps[n-1][m-1]-1


# print(solution([[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]))
# print(solution([[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]]))

# -------------------------------------------------------------------------------- 9. 구명보트 - 복습!!
# 구명보트를 최대한 적게 사용하여 모든 사람을 구출
# 2명씩이 최대
# 구현도 구현이지만 
# 이걸 보고 투포인터인줄 모르는게 문제다!!!

# ------------------------------------------- 내꺼 이전꺼ㅋㅋㅋㅋ
# def solution(people, limit):
#   people.sort()
#   small_i = 0
#   big_i = len(people)-1
#   count = 0
#   while small_i <= big_i:
#     if people[small_i] + people[big_i] <= limit:
#       big_i -= 1
#       small_i += 1
#       count += 1
#     else:
#       big_i -= 1
#       count += 1

#   return count

# print(solution([20,30,50,70,100], 100))
# print(solution([20,30,70,50,80,50], 100))
# print(solution([70,50,80,50], 100))
# print(solution([70,80,50],	100))
# print(solution([20,30,50],	100))

# -------------------------------------------------------------------------------- 4. 방문길이
# ------------------------------------------- 내꺼 32분 컷!!
# ------------------------------------------- 내꺼 방향이 무방향이다!!!
# dx = [-1,0,1,0]
# dy = [0,1,0,-1]

# def move(x,y,d,visited,answer):
#   nx = x + dx[d]
#   ny = y + dy[d]
#   if 0 <= nx < 11 and 0 <= ny < 11:
#     if (x,y,nx,ny) not in visited:
#       visited.append((x,y,nx,ny))
#       visited.append((nx,ny,x,y))
#       answer += 1
#     return nx,ny,answer
#   return x,y,answer


# def solution(dirs):
#   visited = []
#   x = 5
#   y = 5

#   answer = 0
#   for direc in dirs:
#     if direc == 'U':
#       x,y,answer = move(x,y,0,visited,answer)
#     elif direc == 'R':
#       x,y,answer = move(x,y,1,visited,answer)
#     elif direc == 'D':
#       x,y,answer = move(x,y,2,visited,answer)
#     elif direc == 'L':
#       x,y,answer = move(x,y,3,visited,answer)

#   return answer


# print(solution("ULURRDLLU"))
# print(solution("LULLLLLLU"))
# print(solution("L"))

# -------------------------------------------------------------------------------- 8. n^2 배열 자르기 - 실패! 그래도 복습 할 가치가 있다!
# 시키는 대로 따라하는 것이 아니라 규칙을 알아내야해!
# 아니 이걸 어떻게 알아내...?
# 몫과 나머지
# ------------------------------------------- 내꺼 시간초과
# def solution(n, left, right):
#     n = int(n)
#     answer = []
#     for i in range(n*n):
#         a = i//n
#         b = i%n 
#         print(a,b)
#         if a < b: 
#           a,b = b,a
#         answer.append(a)
#     return answer

# print(solution(3,2,5))
# print(solution(4,7,14))


# -------------------------------------------------------------------------------- 2. 예상 대진표 성공 but 시간초관
# ------------------------------------------- 내꺼 
# -------------------------------------------------------------------------------- 4. 가장 큰 정사각형 찾기
# 동적 프로그래밍 문제인지 알고 푸는 것과
# 모르고 접하는 것은 천지차이...
# ------------------------------------------- 내꺼 전부 통과 그러나 시간초과ㅋㅋㅋㅋ
# -------------------------------------------------------------------------------- 5. 점프와 순간이동
# https://velog.io/@ju_h2/Python-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level2-%EC%A0%90%ED%94%84%EC%99%80-%EC%88%9C%EA%B0%84-%EC%9D%B4%EB%8F%99
# ------------------------------------------- 내꺼 전부 통과 그러나 시간초과ㅋㅋㅋㅋ
# 동적프로그래밍 인줄 알았는데...
# -------------------------------------------------------------------------------- 8. n진수 게임 거의 40분...? 시간초과!
# 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임
# ------------------------------------------- 내꺼 뭔가 나쁘진 않다. 진수변환 정도는 아예 외우자!!!
# -------------------------------------------------------------------------------- 4. 메뉴 리뉴얼
# # ------------------------------------------- 내꺼 구현은 괜춘 그러나 시간초과
# -------------------------------------------------------------------------------- 6. [1차] 프렌즈4블록
# 돌려놓고 생각하자
# ------------------------------------------- 내꺼
# -------------------------------------------------------------------------------- 9. 순위 검색 - 시간초과!
# 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구
# info 배열의 크기는 1 이상 50,000 이하
# query 배열의 크기는 1 이상 100,000 이하
# 나눈 다음 정렬을 좀 해놓을까...?
# 그 후 이진탐색..? 맞추긴 했다ㅋㅋㅋㅋㅋㅋㅋ
# string을 index값으로 바꿔도 큰 차이는 없다. 오히려 string이 빠르다!!
# ------------------------------------------- 내꺼 - 정확도는 ok but 시간초과 